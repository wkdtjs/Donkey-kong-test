<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Donkey Kong (1981) - Advanced Edition</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-database-compat.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        * {
            font-family: 'Press Start 2P', cursive;
        }
        
        body {
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            min-height: 100vh;
            touch-action: manipulation; /* 모바일 터치 확대 방지 */
        }
        
        .game-container {
            image-rendering: pixelated;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }
        
        canvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        .pixel-border {
            border: 4px solid #f39c12;
            box-shadow: 0 0 0 4px #c0392b, 0 0 20px rgba(243, 156, 18, 0.5);
        }
        
        .retro-btn {
            background: linear-gradient(180deg, #e74c3c 0%, #c0392b 100%);
            border: 3px solid #f39c12;
            text-shadow: 2px 2px 0 #000;
            transition: all 0.1s;
        }
        
        .retro-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(243, 156, 18, 0.7);
        }
        
        .retro-btn:active {
            transform: scale(0.95);
        }
        
        .glow-text {
            text-shadow: 0 0 10px #f39c12, 0 0 20px #f39c12, 0 0 30px #f39c12;
        }

        .leaderboard-row:nth-child(odd) {
            background: rgba(243, 156, 18, 0.1);
        }
        
        .leaderboard-row:nth-child(even) {
            background: rgba(231, 76, 60, 0.1);
        }
        
        /* 모바일 컨트롤 버튼 스타일 */
        .control-pad {
            user-select: none;
            -webkit-user-select: none;
        }
    </style>
</head>
<body class="text-white overflow-x-hidden">
    <!-- Login Screen -->
    <div id="loginScreen" class="min-h-screen flex items-center justify-center p-4">
        <div class="bg-gray-900 pixel-border rounded-lg p-8 max-w-md w-full relative overflow-hidden">
            <!-- 배경 장식 -->
            <div class="absolute top-0 left-0 w-full h-2 bg-gradient-to-r from-red-500 via-yellow-500 to-blue-500"></div>
            
            <h1 class="text-2xl text-yellow-400 glow-text text-center mb-2">DONKEY KONG</h1>
            <p class="text-xs text-red-500 text-center mb-8">~ ADVANCED EDITION ~</p>
            
            <div class="space-y-6">
                <div>
                    <label class="text-xs text-yellow-400 block mb-2">PLAYER NAME</label>
                    <input type="text" id="playerName" 
                           class="w-full bg-gray-800 border-2 border-yellow-600 rounded p-3 text-white text-sm focus:outline-none focus:border-yellow-400"
                           placeholder="Enter name..." maxlength="12">
                </div>
                
                <div>
                    <label class="text-xs text-yellow-400 block mb-2">STUDENT ID</label>
                    <input type="text" id="studentId" 
                           class="w-full bg-gray-800 border-2 border-yellow-600 rounded p-3 text-white text-sm focus:outline-none focus:border-yellow-400"
                           placeholder="Enter ID..." maxlength="15">
                </div>
                
                <button onclick="login()" class="retro-btn w-full py-4 rounded text-white text-sm cursor-pointer">
                    START GAME
                </button>
                
                <button onclick="showLeaderboard()" class="retro-btn w-full py-3 rounded text-white text-xs bg-gradient-to-b from-blue-600 to-blue-800 cursor-pointer">
                    VIEW LEADERBOARD
                </button>
            </div>
            
            <div class="mt-6 text-center">
                <p class="text-[10px] text-gray-500">Use ARROW KEYS to move & climb</p>
                <p class="text-[10px] text-gray-500">SPACE to jump</p>
            </div>
        </div>
    </div>

    <!-- Game Screen -->
    <div id="gameScreen" class="hidden min-h-screen flex flex-col items-center justify-center p-2">
        <div class="mb-2 flex flex-wrap justify-center gap-4 md:gap-8 w-full max-w-[512px]">
            <div class="text-center">
                <p class="text-[10px] text-yellow-400">PLAYER</p>
                <p id="displayName" class="text-xs text-white">---</p>
            </div>
            <div class="text-center">
                <p class="text-[10px] text-yellow-400">SCORE</p>
                <p id="scoreDisplay" class="text-lg text-red-500 glow-text">0</p>
            </div>
            <div class="text-center">
                <p class="text-[10px] text-yellow-400">LIVES</p>
                <p id="livesDisplay" class="text-lg text-red-500">❤❤❤</p>
            </div>
            <div class="text-center">
                <p class="text-[10px] text-yellow-400">LEVEL</p>
                <p id="levelDisplay" class="text-lg text-white">1</p>
            </div>
        </div>
        
        <div class="game-container pixel-border rounded bg-black">
            <canvas id="gameCanvas" width="512" height="448" class="w-full h-auto max-w-full"></canvas>
        </div>
        
        <div class="mt-4 flex gap-4">
            <button onclick="restartGame()" class="retro-btn px-6 py-2 rounded text-xs cursor-pointer">RESTART</button>
            <button onclick="backToMenu()" class="retro-btn px-6 py-2 rounded text-xs bg-gradient-to-b from-gray-600 to-gray-800 cursor-pointer">MENU</button>
        </div>
        
        <!-- Mobile Controls -->
        <div class="mt-4 md:hidden grid grid-cols-3 gap-2 w-64 control-pad">
            <div></div>
            <button ontouchstart="mobileControl('up')" ontouchend="mobileControlEnd('up')" class="retro-btn p-4 rounded text-xl flex items-center justify-center active:bg-red-700">▲</button>
            <div></div>
            <button ontouchstart="mobileControl('left')" ontouchend="mobileControlEnd('left')" class="retro-btn p-4 rounded text-xl flex items-center justify-center active:bg-red-700">◀</button>
            <button ontouchstart="mobileControl('jump')" ontouchend="mobileControlEnd('jump')" class="retro-btn p-2 rounded text-[10px] flex items-center justify-center font-bold active:bg-red-700">JUMP</button>
            <button ontouchstart="mobileControl('right')" ontouchend="mobileControlEnd('right')" class="retro-btn p-4 rounded text-xl flex items-center justify-center active:bg-red-700">▶</button>
            <div></div>
            <button ontouchstart="mobileControl('down')" ontouchend="mobileControlEnd('down')" class="retro-btn p-4 rounded text-xl flex items-center justify-center active:bg-red-700">▼</button>
            <div></div>
        </div>
    </div>

    <!-- Leaderboard Screen -->
    <div id="leaderboardScreen" class="hidden min-h-screen flex items-center justify-center p-4">
        <div class="bg-gray-900 pixel-border rounded-lg p-6 max-w-lg w-full">
            <h2 class="text-xl text-yellow-400 glow-text text-center mb-6">HIGH SCORES</h2>
            
            <div class="space-y-2 max-h-96 overflow-y-auto" id="leaderboardList">
                <p class="text-center text-gray-500 text-xs">Loading...</p>
            </div>
            
            <button onclick="backToLogin()" class="retro-btn w-full py-3 rounded text-white text-xs mt-6 cursor-pointer">
                BACK TO MENU
            </button>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div id="gameOverModal" class="hidden fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-50">
        <div class="bg-gray-900 pixel-border rounded-lg p-8 text-center animate-bounce-in">
            <h2 class="text-2xl text-red-500 glow-text mb-4">GAME OVER</h2>
            <p class="text-yellow-400 text-sm mb-2">FINAL SCORE</p>
            <p id="finalScore" class="text-3xl text-white mb-6">0</p>
            <div class="space-y-3">
                <button onclick="restartGame()" class="retro-btn w-full py-3 rounded text-sm cursor-pointer">PLAY AGAIN</button>
                <button onclick="backToMenu()" class="retro-btn w-full py-3 rounded text-xs bg-gradient-to-b from-gray-600 to-gray-800 cursor-pointer">MAIN MENU</button>
            </div>
        </div>
    </div>

    <!-- Victory Modal -->
    <div id="victoryModal" class="hidden fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-50">
        <div class="bg-gray-900 pixel-border rounded-lg p-8 text-center">
            <h2 class="text-2xl text-yellow-400 glow-text mb-4">VICTORY!</h2>
            <p class="text-green-400 text-sm mb-2">LEVEL COMPLETE!</p>
            <p class="text-yellow-400 text-sm mb-2">SCORE</p>
            <p id="victoryScore" class="text-3xl text-white mb-6">0</p>
            <div class="space-y-3">
                <button onclick="nextLevel()" class="retro-btn w-full py-3 rounded text-sm cursor-pointer animate-pulse">NEXT LEVEL</button>
                <button onclick="backToMenu()" class="retro-btn w-full py-3 rounded text-xs bg-gradient-to-b from-gray-600 to-gray-800 cursor-pointer">MAIN MENU</button>
            </div>
        </div>
    </div>

    <script>
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCnPNUCMQlQmPJJ3C76agBWv6zcMQk22hM",
            authDomain: "donkey-kong-ad236.firebaseapp.com",
            databaseURL: "https://donkey-kong-ad236-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "donkey-kong-ad236",
            storageBucket: "donkey-kong-ad236.firebasestorage.app",
            messagingSenderId: "87739350642",
            appId: "1:87739350642:web:11dc8bad05af8e14024ceb",
            measurementId: "G-LJEPXLFS34"
        };

        let database;
        try {
            firebase.initializeApp(firebaseConfig);
            database = firebase.database();
        } catch (e) {
            console.log("Firebase not configured - using local storage");
        }

        // Game State
        let canvas, ctx;
        let player = { name: '', studentId: '' };
        let gameState = {
            score: 0,
            lives: 3,
            level: 1,
            isRunning: false
        };

        // Game Constants
        const GRAVITY = 0.5;
        const JUMP_FORCE = -5;
        const MOVE_SPEED = 3;
        const CLIMB_SPEED = 2.5;
        const CANVAS_WIDTH = 512;
        const CANVAS_HEIGHT = 448;
        const PLATFORM_HEIGHT = 16; // 약간 두껍게 수정
        
        // Game Objects
        let mario = {};
        let donkeyKong = {};
        let pauline = {};
        let barrels = [];
        let platforms = [];
        let ladders = [];
        let keys = { left: false, right: false, up: false, down: false, jump: false };
        let jumpReleased = true;

        // 플랫폼 생성 유틸리티
        function createPlatform(x, y, width, level, direction) {
            return { x, y, width, height: PLATFORM_HEIGHT, level, direction };
        }

        function createLadder(x, y, height) {
            return { x, y, width: 20, height };
        }

        function initLevel() {
            platforms = [];
            ladders = [];
            barrels = [];

            const platformY = [420, 350, 280, 210, 140, 70]; // 6층 구조
            const gapSize = 50; // 드럼통이 떨어질 구멍 크기
            const platformGap = 70; // 층간 간격

            // 1. 플랫폼 생성 로직 (스테이지별 변형)
            
            // Ground (Level 0) - 항상 바닥은 튼튼하게
            platforms.push(createPlatform(0, platformY[0], CANVAS_WIDTH, 0, 1));

            // 중간 층들 (Level 1~4)
            for (let i = 1; i <= 4; i++) {
                const y = platformY[i];
                // 짝수 층은 오른쪽으로 흐름 (왼쪽이 높음), 홀수 층은 왼쪽으로 흐름
                // 시각적 기울기는 캔버스 회전 없이 로직으로 처리 (direction)
                const direction = (i % 2 === 0) ? 1 : -1; 
                
                // 스테이지 난이도에 따른 플랫폼 형태 변경
                if (gameState.level === 1) {
                    // Level 1: 클래식 지그재그
                    if (direction === 1) { // 오른쪽으로 이동 -> 오른쪽에 구멍
                        platforms.push(createPlatform(0, y, CANVAS_WIDTH - gapSize, i, direction));
                        // 사다리 배치 (구멍 반대편)
                        ladders.push(createLadder(50, y, platformGap));
                        ladders.push(createLadder(CANVAS_WIDTH - 150, y, platformGap)); 
                    } else { // 왼쪽으로 이동 -> 왼쪽에 구멍
                        platforms.push(createPlatform(gapSize, y, CANVAS_WIDTH - gapSize, i, direction));
                        // 사다리 배치
                        ladders.push(createLadder(CANVAS_WIDTH - 70, y, platformGap));
                        ladders.push(createLadder(150, y, platformGap));
                    }
                } else if (gameState.level >= 2) {
                    // Level 2+: 중간 구멍 추가 (Swiss Cheese)
                    const holeCount = Math.min(3, gameState.level); // 레벨이 높을수록 구멍 많아짐
                    
                    if (direction === 1) {
                        // 오른쪽 끝 구멍은 필수 (떨어져야 하니까)
                        let currentX = 0;
                        const segmentWidth = (CANVAS_WIDTH - gapSize) / (holeCount + 1);
                        
                        for(let h=0; h <= holeCount; h++) {
                            // 마지막 세그먼트가 아니면 중간에 구멍 뚫기
                            let w = (h === holeCount) ? (CANVAS_WIDTH - gapSize - currentX) : (segmentWidth - 20);
                            platforms.push(createPlatform(currentX, y, w, i, direction));
                            
                            // 사다리 랜덤 배치
                            if(Math.random() > 0.3) {
                                ladders.push(createLadder(currentX + w/2, y, platformGap));
                            }
                            
                            currentX += w + 20; // 20px 중간 구멍
                        }
                    } else {
                        // 왼쪽 끝 구멍 필수
                        let currentX = gapSize;
                        const totalWidth = CANVAS_WIDTH - gapSize;
                        const segmentWidth = totalWidth / (holeCount + 1);

                        for(let h=0; h <= holeCount; h++) {
                             let w = (h === holeCount) ? (CANVAS_WIDTH - currentX) : (segmentWidth - 20);
                             platforms.push(createPlatform(currentX, y, w, i, direction));
                             
                             if(Math.random() > 0.3) {
                                ladders.push(createLadder(currentX + w/2, y, platformGap));
                             }

                             currentX += w + 20;
                        }
                    }
                }
            }

            // Top Floor (Level 5) - DK & Pauline
            platforms.push(createPlatform(0, platformY[5], 250, 5, 0));
            // 마지막 사다리 (Pauline에게 가는 길)
            ladders.push(createLadder(180, platformY[5], platformGap));
            // 바닥 연결 사다리 보강
            ladders.push(createLadder(400, platformY[1], platformGap));


            // 캐릭터 초기화
            mario = {
                x: 30,
                y: platformY[0] - 32,
                width: 24,
                height: 32,
                vx: 0,
                vy: 0,
                onGround: true,
                climbing: false,
                facing: 1,
                frame: 0
            };

            donkeyKong = {
                x: 30,
                y: platformY[5] - 56,
                width: 64,
                height: 56,
                frame: 0,
                throwTimer: 0
            };

            pauline = {
                x: 160,
                y: platformY[5] - 32,
                width: 24,
                height: 32
            };

            jumpReleased = true;
        }

        function login() {
            const name = document.getElementById('playerName').value.trim();
            const id = document.getElementById('studentId').value.trim();

            if (!name || !id) {
                alert('Please enter both name and student ID!');
                return;
            }

            player.name = name;
            player.studentId = id;

            document.getElementById('loginScreen').classList.add('hidden');
            document.getElementById('gameScreen').classList.remove('hidden');
            document.getElementById('displayName').textContent = name;

            startGame();
        }

        function startGame() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

            // 모바일 반응형 캔버스 크기 조정
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            gameState.score = 0;
            gameState.lives = 3;
            gameState.level = 1;
            gameState.isRunning = true;

            updateUI();
            initLevel();
            requestAnimationFrame(gameLoop);
        }

        function resizeCanvas() {
            // 비율 유지하면서 화면에 맞춤
            const container = document.querySelector('.game-container');
            const aspect = CANVAS_WIDTH / CANVAS_HEIGHT;
            let w = container.clientWidth;
            let h = w / aspect;
            
            // 캔버스 내부 해상도는 고정
            canvas.style.width = '100%';
            canvas.style.height = 'auto';
        }

        let lastTime = 0;
        function gameLoop(timestamp) {
            if (!gameState.isRunning) return;

            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            update();
            draw();

            requestAnimationFrame(gameLoop);
        }

        function update() {
            updateMario();
            updateBarrels();
            updateDonkeyKong();
            checkVictory();
        }

        function updateMario() {
            // 사다리 판정 로직
            let currentLadder = null;
            const marioCenter = mario.x + mario.width / 2;
            const marioBottom = mario.y + mario.height;

            for (let ladder of ladders) {
                // 사다리 범위 체크
                if (Math.abs(marioCenter - (ladder.x + ladder.width / 2)) < 15 &&
                    marioBottom >= ladder.y - 5 && 
                    marioBottom <= ladder.y + ladder.height + 5) {
                    currentLadder = ladder;
                    break;
                }
            }

            if (mario.climbing) {
                mario.vx = 0;
                mario.vy = 0;

                if (keys.up) {
                    mario.y -= CLIMB_SPEED;
                    mario.frame = (mario.frame + 0.1) % 4;
                }
                if (keys.down) {
                    mario.y += CLIMB_SPEED;
                    mario.frame = (mario.frame + 0.1) % 4;
                }

                // 사다리 정상 도착
                if (currentLadder && marioBottom <= ladderTop(currentLadder) + 2) {
                    mario.y = ladderTop(currentLadder) - mario.height;
                    mario.climbing = false;
                    mario.onGround = true;
                }

                // 사다리 바닥 도착 (내려올 때)
                if (currentLadder && marioBottom >= ladderBottom(currentLadder)) {
                    mario.climbing = false;
                    mario.onGround = true;
                }
                
                // 사다리 영역을 완전히 벗어나면 추락
                if (!currentLadder) {
                    mario.climbing = false;
                }

                if (keys.left || keys.right) {
                    mario.climbing = false;
                }

            } else {
                // 좌우 이동 및 점프 로직 (기존과 동일)
                if (keys.left) {
                    mario.vx = -MOVE_SPEED;
                    mario.facing = -1;
                    mario.frame = (mario.frame + 0.15) % 4;
                } else if (keys.right) {
                    mario.vx = MOVE_SPEED;
                    mario.facing = 1;
                    mario.frame = (mario.frame + 0.15) % 4;
                } else {
                    mario.vx = 0;
                }

                mario.vy += GRAVITY;
                if (mario.vy > 12) mario.vy = 12;

                if (keys.jump && mario.onGround && jumpReleased) {
                    mario.vy = JUMP_FORCE;
                    mario.onGround = false;
                    jumpReleased = false;
                }

                // 사다리 타기 시작 (위로)
                if (currentLadder && keys.up) {
                    mario.x = currentLadder.x + currentLadder.width / 2 - mario.width / 2;
                    mario.climbing = true;
                    mario.vy = 0;
                }

                // 사다리 타기 시작 (아래로)
                if (keys.down && mario.onGround) {
                     for (let ladder of ladders) {
                        const ladderCenter = ladder.x + ladder.width / 2;
                        // 발 위치가 사다리 상단 근처인지 확인
                        if (Math.abs(marioCenter - ladderCenter) < 15 &&
                            Math.abs(marioBottom - ladder.y) < 10) {
                            
                            mario.x = ladderCenter - mario.width / 2;
                            mario.climbing = true;
                            mario.onGround = false;
                            mario.y += 5; // 사다리 안쪽으로 살짝 이동
                            break;
                        }
                    }
                }

                mario.x += mario.vx;
                mario.y += mario.vy;

                // *** 수정됨: 사다리를 타고 있는 상태가 아닐 때만 플랫폼 충돌 감지 실행 ***
                if (!mario.climbing) {
                    mario.onGround = false;
                    for (let platform of platforms) {
                        if (mario.vy >= 0 && // 떨어지는 중일 때만
                            mario.x + mario.width > platform.x &&
                            mario.x < platform.x + platform.width &&
                            mario.y + mario.height >= platform.y &&
                            mario.y + mario.height <= platform.y + 16) {
                            
                            mario.y = platform.y - mario.height;
                            mario.vy = 0;
                            mario.onGround = true;
                            break;
                        }
                    }
                }
            }

            if (!keys.jump) jumpReleased = true;

            // 화면 경계 체크
            if (mario.x < 0) mario.x = 0;
            if (mario.x > CANVAS_WIDTH - mario.width) mario.x = CANVAS_WIDTH - mario.width;
            
            if (mario.y > CANVAS_HEIGHT) loseLife();
        }

        function ladderTop(l) { return l.y; }
        function ladderBottom(l) { return l.y + l.height; }

        function updateDonkeyKong() {
            donkeyKong.throwTimer++;
            // 레벨이 오를수록 던지는 속도 빨라짐
            const throwInterval = Math.max(60, 150 - gameState.level * 15);
            
            if (donkeyKong.throwTimer >= throwInterval) {
                throwBarrel();
                donkeyKong.throwTimer = 0;
                donkeyKong.frame = (donkeyKong.frame + 1) % 2;
            }
        }

        function throwBarrel() {
            // DK 바로 옆에서 생성
            barrels.push({
                x: donkeyKong.x + 60,
                y: donkeyKong.y + 20, 
                width: 16,
                height: 16,
                vx: 3 + gameState.level * 0.5,
                vy: 0,
                onGround: false,
                frame: 0,
                scored: false,
                falling: true
            });
        }

        function updateBarrels() {
            for (let i = barrels.length - 1; i >= 0; i--) {
                let barrel = barrels[i];

                // 중력 적용
                if (!barrel.onGround) {
                    barrel.vy += GRAVITY;
                    if (barrel.vy > 10) barrel.vy = 10;
                }

                // X축 이동 (벽 충돌 처리 핵심)
                let nextX = barrel.x + barrel.vx;
                
                // 1. 벽 충돌 (Bounce Logic) - 드럼통이 벽을 뚫지 않게 함
                if (nextX <= 0) {
                    barrel.x = 0;
                    barrel.vx = Math.abs(barrel.vx); // 오른쪽으로 튕김
                } else if (nextX + barrel.width >= CANVAS_WIDTH) {
                    barrel.x = CANVAS_WIDTH - barrel.width;
                    barrel.vx = -Math.abs(barrel.vx); // 왼쪽으로 튕김
                } else {
                    barrel.x = nextX;
                }

                barrel.y += barrel.vy;

                // 회전 애니메이션
                barrel.frame = (barrel.frame + Math.abs(barrel.vx) * 0.1) % 4;

                // 플랫폼 충돌 검사
                let wasOnGround = barrel.onGround;
                barrel.onGround = false;

                for (let platform of platforms) {
                    // 배럴의 발이 플랫폼 높이 근처에 있고, 배럴이 플랫폼 위에 수평적으로 위치하는지
                    if (barrel.vy >= 0 && // 떨어지는 중
                        barrel.x + barrel.width > platform.x && // 왼쪽 경계
                        barrel.x < platform.x + platform.width && // 오른쪽 경계
                        barrel.y + barrel.height >= platform.y &&
                        barrel.y + barrel.height <= platform.y + 20) { // 플랫폼 착지
                        
                        barrel.y = platform.y - barrel.height;
                        barrel.vy = 0;
                        barrel.onGround = true;
                        
                        // 플랫폼 방향에 따라 가속 또는 방향 전환
                        // level이 0이 아니면(땅바닥 제외) 플랫폼 방향으로 이동
                        if (platform.level > 0) {
                            const speed = 2 + gameState.level * 0.3;
                            // 플랫폼이 기울어진 방향으로 vx 설정
                            // 만약 이미 그 방향으로 가고 있다면 가속, 아니면 전환
                            // 여기서는 단순하게 플랫폼 방향으로 강제
                            if (platform.direction !== 0) {
                                barrel.vx = platform.direction * speed;
                            }
                        } else {
                            // 땅바닥(Level 0)에서는 굴러오던 방향 유지
                            if (Math.abs(barrel.vx) < 1) barrel.vx = (Math.random() > 0.5 ? 2 : -2);
                        }
                        break;
                    }
                }

                // 플랫폼을 벗어나면 추락 상태로 변경 (구멍에 빠짐)
                if (wasOnGround && !barrel.onGround) {
                    // 구멍으로 떨어질 때 약간의 수평 속도 유지
                    // 하지만 벽에 부딪혀서 떨어진 경우는 vx가 반전되었을 것임
                }

                // 화면 아래로 나가면 제거 (성공적으로 떨어진 배럴)
                if (barrel.y > CANVAS_HEIGHT) {
                    barrels.splice(i, 1);
                    continue;
                }

                // 마리오 충돌
                if (checkCollision(mario, barrel)) {
                    barrels.splice(i, 1);
                    loseLife();
                    return; // *** 버그 수정: loseLife()가 배열을 비우므로 즉시 리턴해야 함 ***
                }

                // 점수 획득 (뛰어넘기)
                if (!barrel.scored && 
                    !mario.climbing &&
                    mario.y + mario.height < barrel.y &&
                    Math.abs((mario.x + mario.width/2) - (barrel.x + barrel.width/2)) < 20) {
                    barrel.scored = true;
                    gameState.score += 100;
                    createScoreEffect(barrel.x, barrel.y, 100);
                    updateUI();
                }
            }
        }

        // 점수 이펙트 (간단한 시각 효과)
        let scoreEffects = [];
        function createScoreEffect(x, y, score) {
            scoreEffects.push({x, y, text: score, timer: 30});
        }
        function drawScoreEffects() {
            ctx.fillStyle = '#ffff00';
            ctx.font = '10px "Press Start 2P"';
            for(let i=scoreEffects.length-1; i>=0; i--) {
                let effect = scoreEffects[i];
                ctx.fillText(effect.text, effect.x, effect.y);
                effect.y -= 1;
                effect.timer--;
                if(effect.timer <= 0) scoreEffects.splice(i, 1);
            }
        }

        function checkCollision(a, b) {
            const padding = 6; // 충돌 판정 약간 완화
            return a.x + padding < b.x + b.width - padding &&
                   a.x + a.width - padding > b.x + padding &&
                   a.y + padding < b.y + b.height - padding &&
                   a.y + a.height - padding > b.y + padding;
        }

        function checkVictory() {
            if (checkCollision(mario, pauline)) {
                victory();
            }
        }

        function loseLife() {
            gameState.lives--;
            updateUI();
            barrels = [];
            
            // 화면 흔들림 효과
            canvas.style.transform = 'translate(5px, 5px)';
            setTimeout(() => canvas.style.transform = 'translate(-5px, -5px)', 50);
            setTimeout(() => canvas.style.transform = 'none', 100);

            if (gameState.lives <= 0) {
                gameOver();
            } else {
                mario.x = 30;
                mario.y = 420 - 32; // Ground Level
                mario.vx = 0;
                mario.vy = 0;
                mario.onGround = true;
                mario.climbing = false;
                jumpReleased = true;
            }
        }

        function gameOver() {
            gameState.isRunning = false;
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('gameOverModal').classList.remove('hidden');
            saveScore();
        }

        function victory() {
            gameState.isRunning = false;
            gameState.score += 1000 + (gameState.level * 500);
            document.getElementById('victoryScore').textContent = gameState.score;
            document.getElementById('victoryModal').classList.remove('hidden');
            updateUI();
            saveScore();
        }

        function nextLevel() {
            document.getElementById('victoryModal').classList.add('hidden');
            gameState.level++;
            gameState.isRunning = true;
            initLevel();
            updateUI();
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        function draw() {
            // 배경
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // 플랫폼
            for (let platform of platforms) {
                drawPlatform(platform);
            }

            // 사다리
            for (let ladder of ladders) {
                drawLadder(ladder);
            }

            drawDonkeyKong();
            drawPauline();

            for (let barrel of barrels) {
                drawBarrel(barrel);
            }

            drawMario();
            drawScoreEffects();

            // HELP! 텍스트
            if (Math.floor(Date.now() / 500) % 2 === 0) {
                ctx.fillStyle = '#ff69b4';
                ctx.font = '10px "Press Start 2P"';
                ctx.fillText('HELP!', pauline.x - 5, pauline.y - 10);
            }
        }

        function drawPlatform(platform) {
            ctx.fillStyle = '#e74c3c'; // 메인 컬러
            ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
            
            // 철골 디테일
            ctx.fillStyle = '#c0392b'; // 그림자
            ctx.fillRect(platform.x, platform.y + 4, platform.width, platform.height - 8);
            
            // 트러스 구조 무늬
            ctx.fillStyle = '#a93226';
            for (let i = 0; i < platform.width; i += 20) {
                ctx.beginPath();
                ctx.moveTo(platform.x + i, platform.y);
                ctx.lineTo(platform.x + i + 10, platform.y + platform.height);
                ctx.stroke(); // 선만 그림
            }
        }

        function drawLadder(ladder) {
            ctx.fillStyle = '#3498db';
            ctx.fillRect(ladder.x, ladder.y, 4, ladder.height);
            ctx.fillRect(ladder.x + ladder.width - 4, ladder.y, 4, ladder.height);
            
            for (let i = 4; i < ladder.height; i += 10) {
                ctx.fillRect(ladder.x, ladder.y + i, ladder.width, 2);
            }
        }

        function drawMario() {
            ctx.save();
            ctx.translate(Math.floor(mario.x + mario.width / 2), Math.floor(mario.y + mario.height / 2));
            
            if (mario.facing === -1) {
                ctx.scale(-1, 1);
            }

            // Classic Mario Colors
            const red = '#e74c3c';
            const skin = '#f5b041';
            const blue = '#3498db';
            const brown = '#4a2c00';

            // Running Animation Offset
            let runOffset = 0;
            if (Math.abs(mario.vx) > 0 || mario.climbing) {
                runOffset = Math.floor(mario.frame) % 2 === 0 ? -1 : 1;
            }

            // Body
            ctx.fillStyle = blue;
            ctx.fillRect(-6, 2, 12, 10); // Overalls

            // Shirt
            ctx.fillStyle = red;
            ctx.fillRect(-7, -4, 14, 6);
            ctx.fillRect(-9, -2, 18, 4); // Arms

            // Head
            ctx.fillStyle = skin;
            ctx.fillRect(-6, -14, 12, 10);

            // Hat
            ctx.fillStyle = red;
            ctx.fillRect(-7, -16, 16, 4);
            ctx.fillRect(2, -16, 8, 4); // Brim

            // Hair & Mustache
            ctx.fillStyle = brown;
            ctx.fillRect(-7, -12, 4, 3); // Sideburns
            ctx.fillRect(0, -8, 8, 3); // Mustache
            
            // Eye
            ctx.fillStyle = 'black';
            ctx.fillRect(2, -12, 2, 2);

            // Legs
            ctx.fillStyle = blue;
            if (mario.climbing) {
                ctx.fillRect(-7, 12 + runOffset, 5, 4);
                ctx.fillRect(2, 12 - runOffset, 5, 4);
            } else if (!mario.onGround) { // Jumping
                ctx.fillRect(-8, 10, 6, 6);
                ctx.fillRect(4, 8, 6, 6);
            } else { // Running/Standing
                ctx.fillRect(-7 - runOffset, 12, 5, 4);
                ctx.fillRect(2 + runOffset, 12, 5, 4);
            }

            ctx.restore();
        }

        function drawDonkeyKong() {
            ctx.save();
            ctx.translate(donkeyKong.x, donkeyKong.y);

            // Simple DK Sprite Art
            ctx.fillStyle = '#8B4513'; // Brown Fur
            
            // Body depends on animation
            if (donkeyKong.frame === 0) { // Standing
                ctx.fillRect(10, 20, 44, 30);
                // Arms
                ctx.fillRect(0, 25, 10, 25);
                ctx.fillRect(54, 25, 10, 25);
            } else { // Throwing
                ctx.fillRect(10, 20, 44, 30);
                // Arms Up
                ctx.fillRect(0, 10, 10, 25);
                ctx.fillRect(54, 10, 10, 25);
            }

            // Head
            ctx.fillRect(16, 0, 32, 20);
            
            // Face
            ctx.fillStyle = '#DEB887';
            ctx.fillRect(20, 5, 24, 12);
            ctx.fillStyle = 'white';
            ctx.fillRect(24, 7, 6, 4);
            ctx.fillRect(34, 7, 6, 4);
            ctx.fillStyle = 'black';
            ctx.fillRect(26, 8, 2, 2);
            ctx.fillRect(36, 8, 2, 2);

            // Chest
            ctx.fillStyle = '#DEB887';
            ctx.fillRect(22, 25, 20, 15);

            // Tie
            ctx.fillStyle = 'red';
            ctx.fillRect(30, 25, 6, 12);
            ctx.beginPath();
            ctx.moveTo(30, 37);
            ctx.lineTo(33, 42);
            ctx.lineTo(36, 37);
            ctx.fill();

            ctx.restore();
        }

        function drawPauline() {
            ctx.save();
            ctx.translate(pauline.x, pauline.y);
            
            // Dress
            ctx.fillStyle = '#ff69b4';
            ctx.fillRect(6, 14, 12, 18);
            
            // Face
            ctx.fillStyle = '#f5b041';
            ctx.fillRect(8, 2, 8, 8);
            
            // Hair
            ctx.fillStyle = '#5d4037';
            ctx.fillRect(6, 0, 12, 4);
            ctx.fillRect(4, 2, 4, 10);
            ctx.fillRect(16, 2, 4, 10);
            
            // Help Wave Animation
            if (Math.floor(Date.now() / 200) % 2 === 0) {
                 ctx.fillStyle = '#f5b041';
                 ctx.fillRect(18, 14, 4, 8); // Arm Up
            } else {
                 ctx.fillStyle = '#f5b041';
                 ctx.fillRect(18, 18, 4, 8); // Arm Down
            }

            ctx.restore();
        }

        function drawBarrel(barrel) {
            ctx.save();
            ctx.translate(barrel.x + barrel.width / 2, barrel.y + barrel.height / 2);
            ctx.rotate(barrel.frame * Math.PI / 2);

            ctx.fillStyle = '#8d6e63';
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#d7ccc8';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI * 2);
            ctx.stroke();

            ctx.fillStyle = '#5d4037';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('DK', 0, 1);

            ctx.restore();
        }

        function updateUI() {
            document.getElementById('scoreDisplay').textContent = gameState.score;
            document.getElementById('livesDisplay').textContent = '❤'.repeat(Math.max(0, gameState.lives));
            document.getElementById('levelDisplay').textContent = gameState.level;
        }

        // Firebase & Storage Logic
        function saveScore() {
            const scoreData = {
                name: player.name,
                studentId: player.studentId,
                score: gameState.score,
                level: gameState.level,
                timestamp: Date.now()
            };

            if (database) {
                database.ref('leaderboard').push(scoreData)
                    .catch(e => saveToLocalStorage(scoreData));
            } else {
                saveToLocalStorage(scoreData);
            }
        }

        function saveToLocalStorage(scoreData) {
            let scores = JSON.parse(localStorage.getItem('dkScores') || '[]');
            scores.push(scoreData);
            scores.sort((a, b) => b.score - a.score);
            scores = scores.slice(0, 10);
            localStorage.setItem('dkScores', JSON.stringify(scores));
        }

        function showLeaderboard() {
            document.getElementById('loginScreen').classList.add('hidden');
            document.getElementById('leaderboardScreen').classList.remove('hidden');
            loadLeaderboard();
        }

        function loadLeaderboard() {
            const listEl = document.getElementById('leaderboardList');
            listEl.innerHTML = '<p class="text-center text-gray-500 text-xs">Loading...</p>';

            if (database) {
                database.ref('leaderboard')
                    .orderByChild('score')
                    .limitToLast(10)
                    .once('value')
                    .then(snapshot => {
                        const scores = [];
                        snapshot.forEach(child => scores.push(child.val()));
                        scores.reverse(); // 내림차순 정렬
                        displayLeaderboard(scores);
                    })
                    .catch(e => {
                        console.error(e);
                        displayLeaderboard(JSON.parse(localStorage.getItem('dkScores') || '[]'));
                    });
            } else {
                displayLeaderboard(JSON.parse(localStorage.getItem('dkScores') || '[]'));
            }
        }

        function displayLeaderboard(scores) {
            const listEl = document.getElementById('leaderboardList');

            // 점수 내림차순 정렬 재확인
            scores.sort((a, b) => b.score - a.score);

            if (scores.length === 0) {
                listEl.innerHTML = '<p class="text-center text-gray-500 text-xs">No scores yet!</p>';
                return;
            }

            listEl.innerHTML = scores.map((s, i) => `
                <div class="leaderboard-row flex justify-between items-center p-3 rounded ${i < 3 ? 'border-l-4 border-yellow-400' : ''}">
                    <div class="flex items-center gap-3">
                        <span class="text-lg ${i === 0 ? 'text-yellow-400' : i === 1 ? 'text-gray-300' : i === 2 ? 'text-orange-400' : 'text-gray-500'}">${i + 1}</span>
                        <div>
                            <p class="text-sm text-white">${s.name}</p>
                            <p class="text-xs text-gray-500">${s.studentId}</p>
                        </div>
                    </div>
                    <div class="text-right">
                        <p class="text-sm text-yellow-400">${s.score}</p>
                        <p class="text-xs text-gray-500">LVL ${s.level || 1}</p>
                    </div>
                </div>
            `).join('');
        }

        function backToLogin() {
            document.getElementById('leaderboardScreen').classList.add('hidden');
            document.getElementById('loginScreen').classList.remove('hidden');
        }

        function backToMenu() {
            gameState.isRunning = false;
            document.getElementById('gameOverModal').classList.add('hidden');
            document.getElementById('victoryModal').classList.add('hidden');
            document.getElementById('gameScreen').classList.add('hidden');
            document.getElementById('loginScreen').classList.remove('hidden');
        }

        function restartGame() {
            document.getElementById('gameOverModal').classList.add('hidden');
            document.getElementById('victoryModal').classList.add('hidden');
            startGame(); // 완전 재시작
        }

        // 키보드 컨트롤
        document.addEventListener('keydown', (e) => {
            if (!gameState.isRunning) return;
            switch(e.key) {
                case 'ArrowLeft': case 'a': keys.left = true; break;
                case 'ArrowRight': case 'd': keys.right = true; break;
                case 'ArrowUp': case 'w': keys.up = true; break;
                case 'ArrowDown': case 's': keys.down = true; break;
                case ' ': keys.jump = true; break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch(e.key) {
                case 'ArrowLeft': case 'a': keys.left = false; break;
                case 'ArrowRight': case 'd': keys.right = false; break;
                case 'ArrowUp': case 'w': keys.up = false; break;
                case 'ArrowDown': case 's': keys.down = false; break;
                case ' ': keys.jump = false; break;
            }
        });

        // 모바일 컨트롤
        function mobileControl(dir) { keys[dir] = true; }
        function mobileControlEnd(dir) { keys[dir] = false; }
    </script>
</body>
</html>
